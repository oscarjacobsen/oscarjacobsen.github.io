/*!
* rete-context-menu-plugin v1.0.0-alpha9 
* (c) 2022 Vitaliy Stoliarov 
* Released under the MIT license.
*/
'use strict';



function ___$insertStylesToHeader(css) {
  if (!css) {
    return
  }
  if (typeof window === 'undefined') {
    return
  }

  const style = document.createElement('style');

  style.setAttribute('type', 'text/css');
  style.innerHTML = css;
  document.head.appendChild(style);
  return css
}

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
function createNode(_x, _x2) {
  return _createNode.apply(this, arguments);
}

function _createNode() {
  _createNode = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(component, _ref) {
    var _ref$data, data, _ref$meta, meta, _ref$x, x, _ref$y, y, node;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref$data = _ref.data, data = _ref$data === void 0 ? {} : _ref$data, _ref$meta = _ref.meta, meta = _ref$meta === void 0 ? {} : _ref$meta, _ref$x = _ref.x, x = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === void 0 ? 0 : _ref$y;
            _context.next = 3;
            return component.createNode(deepCopy(data));

          case 3:
            node = _context.sent;
            node.meta = Object.assign(deepCopy(meta), node.meta);
            node.position[0] = x;
            node.position[1] = y;
            return _context.abrupt("return", node);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createNode.apply(this, arguments);
}

function traverse(items, callback) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  for (var key in items) {
    var item = items[key];
    if (_typeof(item.subitems) === 'object') traverse(item.subitems, callback, [].concat(_toConsumableArray(path), [key]));else callback(item.title, item.callback, path);
  }
}
function fitViewport(_ref2, element) {
  var _ref3 = _slicedToArray(_ref2, 2),
      x = _ref3[0],
      y = _ref3[1];

  return [Math.min(x, window.innerWidth - element.clientWidth), Math.min(y, window.innerHeight - element.clientHeight)];
}

/**
 * Debounce
 * @see https://www.matthewgerstman.com/tech/throttle-and-debounce/
 * @param {Function} next
 * @param {number} ms
 * @return {Function}
 */
function debounce(next, ms) {
  var timeout;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    clearTimeout(timeout);
    timeout = setTimeout(function () {
      next.apply(void 0, args);
    }, ms);
  };
}

var script$2 = vue.defineComponent({
  props: {
      item: Object,
      args: Object,
      delay: { type: Number, required: true }
  },
  emits: ["hide", "click"],
  setup(props, { emit }) {
      vue.onMounted(() => {
          timeoutHide = debounce(hideSubitems, props.delay);
      });
    let timeoutHide = () => {};
    const visibleSubitems = vue.ref(false);
    const hasSubitems = vue.computed(() => {
          return props.item.subitems
    });
    const cancelHide = () => {
          const hide = timeoutHide;
          if (hide && hide.cancel)
              timeoutHide.cancel();
    };
    const showSubitems = () => {
          visibleSubitems.value = true;
          cancelHide();
      };
    const hideSubitems = () => {
          visibleSubitems.value = false;
    };
    const onClick = (e) => {
      e.stopPropagation();
      emit('click', props.item);
      emit('hide');
    };

    const subitemClicked = (subitem) => {
        emit('click', subitem);
    };

    return {
        onClick,
        showSubitems,
        timeoutHide,
        hasSubitems,
        visibleSubitems,
        subitemClicked
    }
 }
});

const _hoisted_1$1 = {
  key: 0,
  class: "subitems"
};

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Item = vue.resolveComponent("Item", true);

  return (vue.openBlock(), vue.createElementBlock("div", {
    onClick: _cache[1] || (_cache[1] = (...args) => (_ctx.onClick && _ctx.onClick(...args))),
    onMouseover: _cache[2] || (_cache[2] = (...args) => (_ctx.showSubitems && _ctx.showSubitems(...args))),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => (_ctx.timeoutHide && _ctx.timeoutHide(...args))),
    class: vue.normalizeClass(["item", { hasSubitems: _ctx.hasSubitems }])
  }, [
    vue.createTextVNode(vue.toDisplayString(_ctx.item.title) + " ", 1 /* TEXT */),
    (_ctx.hasSubitems && _ctx.visibleSubitems)
      ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.item.subitems, (subitem) => {
            return (vue.openBlock(), vue.createBlock(_component_Item, {
              key: subitem.title,
              item: subitem,
              delay: _ctx.delay,
              onHide: _cache[0] || (_cache[0] = $event => (_ctx.$emit('hide'))),
              onClick: _ctx.subitemClicked
            }, null, 8 /* PROPS */, ["item", "delay", "onClick"]))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
      : vue.createCommentVNode("v-if", true)
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

___$insertStylesToHeader("@charset \"UTF-8\";\n.item, .item[data-v-01b70e4c] .subitems[data-v-01b70e4c] .subitem[data-v-01b70e4c], .item[data-v-01b70e4c] {\n  color: #fff;\n  padding: 4px;\n  border-bottom: 1px solid rgba(69, 103, 255, 0.8);\n  background-color: rgba(110, 136, 255, 0.8);\n  cursor: pointer;\n  width: 100%;\n  position: relative;\n}\n.item:first-child, .item[data-v-01b70e4c] .subitems[data-v-01b70e4c] .subitem[data-v-01b70e4c]:first-child {\n  border-top-left-radius: 5px;\n  border-top-right-radius: 5px;\n}\n.item:last-child, .item[data-v-01b70e4c] .subitems[data-v-01b70e4c] .subitem[data-v-01b70e4c]:last-child {\n  border-bottom-left-radius: 5px;\n  border-bottom-right-radius: 5px;\n}\n.item:hover, .item[data-v-01b70e4c] .subitems[data-v-01b70e4c] .subitem[data-v-01b70e4c]:hover {\n  background-color: rgba(130, 153, 255, 0.8);\n}\n\n.item[data-v-01b70e4c].hasSubitems[data-v-01b70e4c]:after, .item[data-v-01b70e4c] .subitems[data-v-01b70e4c] [data-v-01b70e4c].hasSubitems[data-v-01b70e4c].subitem:after {\n  content: \"►\";\n  position: absolute;\n  opacity: 0.6;\n  right: 5px;\n  top: 5px;\n}\n.item[data-v-01b70e4c] .subitems[data-v-01b70e4c], .item[data-v-01b70e4c] .subitems[data-v-01b70e4c] [data-v-01b70e4c].subitem .subitems[data-v-01b70e4c] {\n  position: absolute;\n  top: 0;\n  left: 100%;\n  width: 120px;\n}");

script$2.render = render$2;
script$2.__scopeId = "data-v-01b70e4c";
script$2.__file = "src/menu/Item.vue";

var script$1 = vue.defineComponent({
    props: {
        value: { type: String, default: '' }
    },
    emits: ["search"],
    setup(props) {
        const valueRef = vue.ref(props.value);
        return {
            valueRef
        }
    }
});

const _hoisted_1 = { class: "search" };

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (vue.openBlock(), vue.createElementBlock("div", _hoisted_1, [
    vue.withDirectives(vue.createElementVNode("input", {
      "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.valueRef) = $event)),
      onChange: _cache[1] || (_cache[1] = $event => (_ctx.$emit('search', _ctx.valueRef)))
    }, null, 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
      [vue.vModelText, _ctx.valueRef]
    ])
  ]))
}

___$insertStylesToHeader(".search[data-v-654ba12f] input[data-v-654ba12f] {\n  color: white;\n  padding: 1px 8px;\n  border: 1px solid white;\n  border-radius: 10px;\n  font-size: 16px;\n  font-family: serif;\n  width: 100%;\n  box-sizing: border-box;\n  background: transparent;\n}");

script$1.render = render$1;
script$1.__scopeId = "data-v-654ba12f";
script$1.__file = "src/menu/Search.vue";

var script = vue.defineComponent({
  components: {
        Item: script$2, Search: script$1
  },
  props: {
      searchBar: {type: Boolean, default: false },
      searchKeep: {type: Function, default: () => {} },
      delay: { type: Number, required: true }
  },
  setup(props) {
      vue.onMounted(() => {
          timeoutHide = debounce(hide, props.delay);
      });
      vue.onUpdated(() => {
          vue.nextTick(() => {
              if (myRefMenu.value) {
                  [posLeft.value, posTop.value] = fitViewport([posLeft.value, posTop.value], myRefMenu.value);
              }
          });
      });
      let timeoutHide = () => {};
      let posLeft = vue.ref(0);
      let posTop = vue.ref(0);
      let items = [];
      const filter = vue.ref('');
      const myRefMenu = vue.ref();
      const visible = vue.ref(false);
      let args = {};
      const style = vue.computed(() => {
          return {
              '--pos-left': posLeft.value+'px',
              '--pos-top': posTop.value+'px'
          }
      });
      const filtered = vue.computed(() => {
          if(!filter.value) return items;
          const regex = new RegExp(filter.value, 'i');

          return extractLeafs(items)
              .filter(({ title }) => {
                  return props.searchKeep(title) || title.match(regex)
              });
      });
      const extractLeafs = (items) => {
          if(!items) return [];
          let leafs = [];
          items.map(item => {
              if(!item.subitems) leafs.push(item);

              leafs.push(...extractLeafs(item.subitems));
          });

          return leafs;
      };
      const onSearch = (e) => {
          filter.value = e;
      };
      const show = (x, y, localArgs = {}) => {
          visible.value = true;
          posLeft.value = x;
          posTop.value = y;
          args = localArgs;

          cancelHide();
      };
      const hide = () => {
          visible.value = false;
      };
      const cancelHide = () => {
          const hide = timeoutHide;
          if (hide && hide.cancel)
              timeoutHide.cancel();
      };
      const additem = (title, onClick, path = []) => {
          for(let level of path) {
              let exist = items.find(i => i.title === level);

              if(!exist) {
                  exist = { title: level, subitems: [] };
                  items.push(exist);
              }

              items = exist.subitems || (exist.subitems = []);
          }

          items.push({ title, onClick });
      };
      const itemClicked = (item) => {
          if(item.onClick)
              item.onClick(args);
      };
      return {
          posLeft,
          posTop,
          visible,
          filter,
          items,
          style,
          filtered,
          myRefMenu,
          extractLeafs,
          onSearch,
          show,
          hide,
          additem,
          timeoutHide,
          cancelHide,
          itemClicked
      }
  }
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Search = vue.resolveComponent("Search");
  const _component_Item = vue.resolveComponent("Item");

  return (_ctx.visible)
    ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: "context-menu",
        ref: "myRefMenu",
        style: vue.normalizeStyle(_ctx.style),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => (_ctx.timeoutHide && _ctx.timeoutHide(...args))),
        onMouseover: _cache[2] || (_cache[2] = (...args) => (_ctx.cancelHide && _ctx.cancelHide(...args))),
        onContextmenu: _cache[3] || (_cache[3] = vue.withModifiers(() => {}, ["prevent"])),
        onWheel: _cache[4] || (_cache[4] = vue.withModifiers(() => {}, ["stop"]))
      }, [
        (_ctx.searchBar)
          ? (vue.openBlock(), vue.createBlock(_component_Search, {
              key: 0,
              modelValue: _ctx.filter,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = $event => ((_ctx.filter) = $event)),
              onSearch: _ctx.onSearch
            }, null, 8 /* PROPS */, ["modelValue", "onSearch"]))
          : vue.createCommentVNode("v-if", true),
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.filtered, (item) => {
          return (vue.openBlock(), vue.createBlock(_component_Item, {
            key: item.title,
            item: item,
            delay: _ctx.delay / 2,
            onHide: _ctx.hide,
            onClick: _ctx.itemClicked
          }, null, 8 /* PROPS */, ["item", "delay", "onHide", "onClick"]))
        }), 128 /* KEYED_FRAGMENT */))
      ], 36 /* STYLE, HYDRATE_EVENTS */))
    : vue.createCommentVNode("v-if", true)
}

___$insertStylesToHeader(".item, .context-menu[data-v-d60fe5b4] .search[data-v-d60fe5b4] {\n  color: #fff;\n  padding: 4px;\n  border-bottom: 1px solid rgba(69, 103, 255, 0.8);\n  background-color: rgba(110, 136, 255, 0.8);\n  cursor: pointer;\n  width: 100%;\n  position: relative;\n}\n.item:first-child, .context-menu[data-v-d60fe5b4] .search[data-v-d60fe5b4]:first-child {\n  border-top-left-radius: 5px;\n  border-top-right-radius: 5px;\n}\n.item:last-child, .context-menu[data-v-d60fe5b4] .search[data-v-d60fe5b4]:last-child {\n  border-bottom-left-radius: 5px;\n  border-bottom-right-radius: 5px;\n}\n.item:hover, .context-menu[data-v-d60fe5b4] .search[data-v-d60fe5b4]:hover {\n  background-color: rgba(130, 153, 255, 0.8);\n}\n\n.context-menu[data-v-d60fe5b4] {\n  left: var(--pos-left, 0);\n  top: var(--pos-top, 0);\n  position: fixed;\n  padding: 10px;\n  width: 120px;\n  margin-top: -20px;\n  margin-left: -60px;\n}");

script.render = render;
script.__scopeId = "data-v-d60fe5b4";
script.__file = "src/menu/Menu.vue";

function createVue(el, vueComponent, vueProps) {
  var app = vue.createApp(vueComponent, vueProps);
  return app.mount(el);
}

var _default = /*#__PURE__*/function () {
  function _default(editor, props, vueComponent) {
    _classCallCheck(this, _default);

    var el = document.createElement('div');
    editor.view.container.appendChild(el);
    this.menu = createVue(el, vueComponent || script, props);
  }

  _createClass(_default, [{
    key: "addItem",
    value: function addItem() {
      var _this$menu;

      (_this$menu = this.menu).additem.apply(_this$menu, arguments);
    }
  }, {
    key: "show",
    value: function show() {
      var _this$menu2;

      (_this$menu2 = this.menu).show.apply(_this$menu2, arguments);
    }
  }, {
    key: "hide",
    value: function hide() {
      this.menu.hide();
    }
  }]);

  return _default;
}();

var MainMenu = /*#__PURE__*/function (_Menu) {
  _inherits(MainMenu, _Menu);

  var _super = _createSuper(MainMenu);

  function MainMenu(editor, props, vueComponent, _ref) {
    var _this;

    var items = _ref.items,
        allocate = _ref.allocate,
        rename = _ref.rename;

    _classCallCheck(this, MainMenu);

    _this = _super.call(this, editor, props, vueComponent);
    var mouse = {
      x: 0,
      y: 0
    };
    editor.on('mousemove', function (_ref2) {
      var x = _ref2.x,
          y = _ref2.y;
      mouse.x = x;
      mouse.y = y;
    });

    var _iterator = _createForOfIteratorHelper(editor.components.values()),
        _step;

    try {
      var _loop = function _loop() {
        var component = _step.value;
        var path = allocate(component);

        if (Array.isArray(path)) {
          // add to the menu if path is an array
          _this.addItem(rename(component), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.t0 = editor;
                    _context.next = 3;
                    return createNode(component, mouse);

                  case 3:
                    _context.t1 = _context.sent;

                    _context.t0.addNode.call(_context.t0, _context.t1);

                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          })), path);
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    traverse(items, function (name, func, path) {
      return _this.addItem(name, func, path);
    });
    return _this;
  }

  return _createClass(MainMenu);
}(_default);

var _excluded = ["name", "position"];

var NodeMenu = /*#__PURE__*/function (_Menu) {
  _inherits(NodeMenu, _Menu);

  var _super = _createSuper(NodeMenu);

  function NodeMenu(editor, props, vueComponent, nodeItems) {
    var _this;

    _classCallCheck(this, NodeMenu);

    _this = _super.call(this, editor, props, vueComponent);

    if (nodeItems["delete"] && !nodeItems["delete"].callback) {
      var defaultDeleteCallback = function defaultDeleteCallback(_ref) {
        var node = _ref.node;

        if (editor.selected.list.indexOf(node) !== -1) {
          editor.selected.remove(node);
        }

        editor.removeNode(node);
      };

      nodeItems["delete"].callback = defaultDeleteCallback;
    }

    if (nodeItems.clone && !nodeItems.clone.callback) {
      var defaultCloneCallback = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(args) {
          var _args$node, name, _args$node$position, x, y, params, component, node;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _args$node = args.node, name = _args$node.name, _args$node$position = _slicedToArray(_args$node.position, 2), x = _args$node$position[0], y = _args$node$position[1], params = _objectWithoutProperties(_args$node, _excluded);
                  component = editor.components.get(name);
                  _context.next = 4;
                  return createNode(component, _objectSpread2(_objectSpread2({}, params), {}, {
                    x: x + 10,
                    y: y + 10
                  }));

                case 4:
                  node = _context.sent;
                  editor.addNode(node);
                  editor.trigger('nodeCloned', node);

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function defaultCloneCallback(_x) {
          return _ref2.apply(this, arguments);
        };
      }();

      nodeItems.clone.callback = defaultCloneCallback;
    }

    if (_typeof(nodeItems) === "object") traverse(nodeItems, function (name, func, path) {
      return _this.addItem(name, func, path);
    });
    return _this;
  }

  return _createClass(NodeMenu);
}(_default);

function install(editor, _ref) {
  var _ref$searchBar = _ref.searchBar,
      searchBar = _ref$searchBar === void 0 ? true : _ref$searchBar,
      _ref$searchKeep = _ref.searchKeep,
      searchKeep = _ref$searchKeep === void 0 ? function () {
    return false;
  } : _ref$searchKeep,
      _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? 1000 : _ref$delay,
      _ref$items = _ref.items,
      items = _ref$items === void 0 ? {} : _ref$items,
      _ref$nodeItems = _ref.nodeItems,
      nodeItems = _ref$nodeItems === void 0 ? {
    "delete": {
      title: "Delete"
    },
    clone: {
      title: "Clone"
    }
  } : _ref$nodeItems,
      _ref$allocate = _ref.allocate,
      allocate = _ref$allocate === void 0 ? function () {
    return [];
  } : _ref$allocate,
      _ref$rename = _ref.rename,
      rename = _ref$rename === void 0 ? function (component) {
    return component.name;
  } : _ref$rename,
      _ref$vueComponent = _ref.vueComponent,
      vueComponent = _ref$vueComponent === void 0 ? null : _ref$vueComponent;
  editor.bind('hidecontextmenu');
  editor.bind('showcontextmenu');
  var mainMenu;
  var currentMenu;
  editor.on('hidecontextmenu', function () {
    if (currentMenu) currentMenu.hide();
  });
  editor.on('click contextmenu', function () {
    editor.trigger('hidecontextmenu');
  });
  editor.on('contextmenu', function (_ref2) {
    var e = _ref2.e,
        node = _ref2.node;
    e.preventDefault();
    e.stopPropagation();
    if (!editor.trigger('showcontextmenu', {
      e: e,
      node: node
    })) return;
    var _ref3 = [e.clientX, e.clientY],
        x = _ref3[0],
        y = _ref3[1];
    var args;

    if (node) {
      currentMenu = new NodeMenu(editor, {
        searchBar: false,
        delay: delay
      }, vueComponent, typeof nodeItems === 'function' ? nodeItems(node) : nodeItems);
      args = {
        node: node
      };
    } else {
      if (!mainMenu) mainMenu = new MainMenu(editor, {
        searchBar: searchBar,
        searchKeep: searchKeep,
        delay: delay
      }, vueComponent, {
        items: items,
        allocate: allocate,
        rename: rename
      });
      currentMenu = mainMenu;
      args = {};
    }

    currentMenu.show(x, y, args);
  });
}

var Menu = script;
var Item = script$2;
var Search = script$1;
var index = {
  name: 'context-menu',
  install: install
};

exports.Item = Item;
exports.Menu = Menu;
exports.Search = Search;
exports["default"] = index;
//# sourceMappingURL=context-menu-plugin.common.js.map
